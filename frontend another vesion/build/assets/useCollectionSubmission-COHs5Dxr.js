var p=Object.defineProperty;var g=(t,e,s)=>e in t?p(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s;var y=(t,e,s)=>g(t,typeof e!="symbol"?e+"":e,s);import{r as c}from"./index-C6fZJ48e.js";import{g as C}from"./gpsValidation-lYsOLY3Q.js";const I=t=>{const e=parseFloat(t);return!isNaN(e)&&e>0&&e<=1e3},D=(t,e)=>t>=-90&&t<=90&&e>=-180&&e<=180,S=async(t,e,s)=>{try{const a=(await s.Collections.list(100,0,t)).items||[],o=new Date().toISOString().split("T")[0];return a.some(i=>i.timestamp.startsWith(o))}catch(r){return console.error("Error checking for duplicate collection:",r),!1}},E="DairyChainDB",x=1,u="collections",f="farmers";class z{constructor(){y(this,"db",null)}async init(){return new Promise((e,s)=>{const r=indexedDB.open(E,x);r.onerror=()=>s(r.error),r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=a=>{const o=a.target.result;if(!o.objectStoreNames.contains(u)){const i=o.createObjectStore(u,{keyPath:"id"});i.createIndex("farmerId","farmerId",{unique:!1}),i.createIndex("synced","synced",{unique:!1}),i.createIndex("timestamp","timestamp",{unique:!1})}if(!o.objectStoreNames.contains(f)){const i=o.createObjectStore(f,{keyPath:"id"});i.createIndex("name","name",{unique:!1}),i.createIndex("phone","phone",{unique:!1}),i.createIndex("nationalId","nationalId",{unique:!1})}}})}async addCollection(e){if(!this.db)throw new Error("Database not initialized");await this.db.transaction([u],"readwrite").objectStore(u).add(e)}async updateCollection(e){if(!this.db)throw new Error("Database not initialized");await this.db.transaction([u],"readwrite").objectStore(u).put(e)}async getUnsyncedCollections(){if(!this.db)throw new Error("Database not initialized");const a=this.db.transaction([u],"readonly").objectStore(u).index("synced").getAll(IDBKeyRange.only(!1));return new Promise((o,i)=>{a.onsuccess=()=>o(a.result),a.onerror=()=>i(a.error)})}async markCollectionAsSynced(e){if(!this.db)throw new Error("Database not initialized");const r=this.db.transaction([u],"readwrite").objectStore(u),a=r.get(e);a.onsuccess=()=>{const o=a.result;o&&(o.synced=!0,r.put(o))}}async addFarmer(e){if(!this.db)throw new Error("Database not initialized");await this.db.transaction([f],"readwrite").objectStore(f).add(e)}async searchFarmers(e){if(!this.db)throw new Error("Database not initialized");const o=this.db.transaction([f],"readonly").objectStore(f).index("name").getAll();return new Promise((i,w)=>{o.onsuccess=()=>{const b=o.result.filter(l=>l.name.toLowerCase().includes(e.toLowerCase())||l.phone.includes(e)||l.nationalId.includes(e));i(b)},o.onerror=()=>w(o.error)})}async getAllFarmers(){if(!this.db)throw new Error("Database not initialized");const r=this.db.transaction([f],"readonly").objectStore(f).getAll();return new Promise((a,o)=>{r.onsuccess=()=>a(r.result),r.onerror=()=>o(r.error)})}}const m=new z,L=()=>{const[t,e]=c.useState(!1),[s,r]=c.useState(null);c.useEffect(()=>{(async()=>{try{await m.init(),e(!0)}catch(h){r("Failed to initialize IndexedDB"),console.error("IndexedDB initialization error:",h)}})()},[]);const a=c.useCallback(async d=>{if(!t)throw new Error("Database not initialized");return m.addCollection(d)},[t]),o=c.useCallback(async d=>{if(!t)throw new Error("Database not initialized");return m.updateCollection(d)},[t]),i=c.useCallback(async()=>{if(!t)throw new Error("Database not initialized");return m.getUnsyncedCollections()},[t]),w=c.useCallback(async d=>{if(!t)throw new Error("Database not initialized");return m.markCollectionAsSynced(d)},[t]),n=c.useCallback(async d=>{if(!t)throw new Error("Database not initialized");return m.addFarmer(d)},[t]),b=c.useCallback(async d=>{if(!t)throw new Error("Database not initialized");return m.searchFarmers(d)},[t]),l=c.useCallback(async()=>{if(!t)throw new Error("Database not initialized");return m.getAllFarmers()},[t]);return{isInitialized:t,error:s,addCollection:a,updateCollection:o,getUnsyncedCollections:i,markCollectionAsSynced:w,addFarmer:n,searchFarmers:b,getAllFarmers:l}},B=t=>{const[e,s]=c.useState(!1),[r,a]=c.useState(null),{addCollection:o,isInitialized:i}=L();return{submitCollection:c.useCallback(async n=>{s(!0),a(null);try{if(!I(n.liters.toString()))throw new Error("Invalid quantity. Please enter a positive number.");if(!D(n.gpsLatitude,n.gpsLongitude))throw new Error("Invalid GPS coordinates.");if(await S(n.farmerId,new Date().toISOString(),t))throw new Error("A collection has already been recorded for this farmer today.");const l=C(n.gpsLatitude,n.gpsLongitude),d={farmer_id:n.farmerId,staff_id:n.staffId,liters:n.liters,gps_latitude:n.gpsLatitude,gps_longitude:n.gpsLongitude,temperature:n.temperature,fat_content:n.fatContent,protein_content:n.proteinContent,validation_code:l,quality_grade:"A",timestamp:new Date().toISOString()};if(i)try{await o({id:`offline-${Date.now()}`,farmerId:n.farmerId,farmerName:n.farmerName,staffId:n.staffId,liters:n.liters,gpsLatitude:n.gpsLatitude,gpsLongitude:n.gpsLongitude,validationCode:l,qualityGrade:"A",temperature:n.temperature,fatContent:n.fatContent,proteinContent:n.proteinContent,timestamp:new Date().toISOString(),synced:!1})}catch(h){console.error("Failed to save to IndexedDB:",h)}return await t.Collections.create(d),s(!1),{success:!0,validationCode:l}}catch(b){const l=b.message||"Failed to submit collection";return a(l),s(!1),{success:!1,error:l}}},[t,i,o]),loading:e,error:r}};export{L as a,D as b,B as u,I as v};
